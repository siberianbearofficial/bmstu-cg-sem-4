{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "An invalid interpreter",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "No Python interpreter configured for the project",
  "detailsInfo": "Reports problems if there is no Python interpreter configured for the project or if the interpreter is invalid. Without a properly\nconfigured interpreter, you cannot execute your Python scripts and benefit from some Python code insight features.\n\nThe IDE provides quick access to the interpreter settings.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/figures/line.py",
      "language": "Python",
      "line": 1,
      "offset": 1,
      "length": 1128,
      "code": {
        "startLine": 1,
        "length": 1128,
        "offset": 0,
        "surroundingCode": "from figures.point import Point\r\n\r\n\r\nclass Line:\r\n    def __init__(self, a, b, c):\r\n        self.a = a\r\n        self.b = b\r\n        self.c = c\r\n\r\n    def x(self, y):\r\n        return (y * self.b + self.c) / -self.a\r\n\r\n    def y(self, x):\r\n        return (x * self.a + self.c) / -self.b\r\n\r\n    def __str__(self):\r\n        return f\"{self.a:3g} * x + {self.b:3g} * y + {self.c:3g} == 0\"\r\n\r\n    def perpendicular(self, point: Point):\r\n        a = self.b\r\n        b = -self.a\r\n        c = -a * point.x - b * point.y\r\n        return Line(a, b, c)\r\n\r\n    def intersection(self, other):\r\n        c = -self.c\r\n        f = -other.c\r\n        p = self.a * other.b - other.a * self.b\r\n        x = (c * other.b - self.b * f) / p\r\n        y = (self.a * f - c * other.a) / p\r\n\r\n        return Point(x, y)\r\n\r\n    @staticmethod\r\n    def from_points(p1: Point, p2: Point):\r\n        a = p2.y - p1.y\r\n        b = p1.x - p2.x\r\n        c = -a * p1.x - b * p1.y\r\n        return Line(a, b, c)\r\n\r\n\r\nif __name__ == '__main__':\r\n    l1 = Line.from_points(Point(1, 1), Point(5, 5))\r\n    l2 = Line.from_points(Point(4, 2), Point(2, 4))\r\n    print(l1)\r\n    print(l2)\r\n    print(tuple(l1.intersection(l2)))\r\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyInterpreterInspection"
  },
  "hash": "0f233d0b2576afe28421275aeef3d8ccc5ae6efe173264042ab4d9afe758968e"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "An invalid interpreter",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "No Python interpreter configured for the project",
  "detailsInfo": "Reports problems if there is no Python interpreter configured for the project or if the interpreter is invalid. Without a properly\nconfigured interpreter, you cannot execute your Python scripts and benefit from some Python code insight features.\n\nThe IDE provides quick access to the interpreter settings.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/figures/triangle.py",
      "language": "Python",
      "line": 1,
      "offset": 1,
      "length": 4145,
      "code": {
        "startLine": 1,
        "length": 4145,
        "offset": 0,
        "surroundingCode": "from math import sqrt, atan\r\nfrom figures.line import Line\r\nfrom figures.point import Point\r\n\r\n\r\nclass NoTriangleException(Exception):\r\n    pass\r\n\r\n\r\nclass Triangle:\r\n    def __init__(self, p1: Point, p2: Point, p3: Point):\r\n        self.p1 = p1\r\n        self.p2 = p2\r\n        self.p3 = p3\r\n\r\n        self.s1 = sqrt((p3.x - p2.x) ** 2 + (p3.y - p2.y) ** 2)\r\n        self.s2 = sqrt((p3.x - p1.x) ** 2 + (p3.y - p1.y) ** 2)\r\n        self.s3 = sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)\r\n\r\n        p = (self.s1 + self.s2 + self.s3) / 2\r\n        self.area = sqrt(p * (p - self.s1) * (p - self.s2) * (p - self.s3))\r\n\r\n        if self.area < 1e-6:\r\n            raise NoTriangleException\r\n\r\n    def height(self, point: Point):\r\n        match point:\r\n            case self.p1:\r\n                return Line.from_points(self.p2, self.p3).perpendicular(self.p1)\r\n            case self.p2:\r\n                return Line.from_points(self.p1, self.p3).perpendicular(self.p2)\r\n            case _:\r\n                return Line.from_points(self.p1, self.p2).perpendicular(self.p3)\r\n\r\n    def __bisector_height_angle(self, point: Point):\r\n        \"\"\"\r\n        Угол между биссектрисой и высотой из вершины point.\r\n        :param point: Вершина для нахождения угла.\r\n        :return: Найденный угол, биссектриса и высота из вершины point.\r\n        \"\"\"\r\n\r\n        points = [self.p1, self.p2, self.p3]\r\n        points.remove(point)\r\n\r\n        height = Line.from_points(*points).perpendicular(point)\r\n\r\n        a, b = points[0], points[1]\r\n        a_point_len = sqrt((a.x - point.x) ** 2 + (a.y - point.y) ** 2)\r\n        b_point_len = sqrt((b.x - point.x) ** 2 + (b.y - point.y) ** 2)\r\n        p = Point(point.x + (b.x - point.x) / b_point_len * a_point_len,\r\n                  point.y + (b.y - point.y) / b_point_len * a_point_len)\r\n        line_a_perp = Line.from_points(point, a).perpendicular(a)\r\n        line_b_perp = Line.from_points(point, b).perpendicular(p)\r\n        line_ab = Line.from_points(a, b)\r\n\r\n        bisector = Line.from_points(point, line_a_perp.intersection(line_b_perp))\r\n\r\n        p1 = bisector.intersection(line_ab)\r\n        p2 = height.intersection(line_ab)\r\n        p12_distance = sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2)\r\n        height_distance = sqrt((point.x - p2.x) ** 2 + (point.y - p2.y) ** 2)\r\n\r\n        return atan(p12_distance / height_distance), bisector, height\r\n\r\n    def max_bisector_height_angle(self):\r\n        \"\"\"\r\n        Максимальный угол между биссектрисой и высотой.\r\n        :return: Найденный угол, вершина, биссектриса и высота из этой вершины.\r\n        \"\"\"\r\n\r\n        res1, bis1, hgt1 = self.__bisector_height_angle(self.p1)\r\n        res2, bis2, hgt2 = self.__bisector_height_angle(self.p2)\r\n        res3, bis3, hgt3 = self.__bisector_height_angle(self.p3)\r\n\r\n        if res1 > res2 and res1 > res3:\r\n            return res1, self.p1, bis1, hgt1\r\n        if res2 > res1 and res2 > res3:\r\n            return res2, self.p2, bis2, hgt2\r\n        return res3, self.p3, bis3, hgt3\r\n\r\n    @staticmethod\r\n    def with_max_bisector_height_angle(points: list[Point]):\r\n        max_bisector_height_angle = None\r\n        max_triangle = None\r\n        max_point = None\r\n        max_bisector = None\r\n        max_height = None\r\n\r\n        for i in range(len(points) - 2):\r\n            for j in range(i + 1, len(points) - 1):\r\n                for k in range(j + 1, len(points)):\r\n                    try:\r\n                        triangle = Triangle(points[i], points[j], points[k])\r\n\r\n                        bisector_height_angle, point, bisector, height = triangle.max_bisector_height_angle()\r\n                        if not max_bisector_height_angle or bisector_height_angle > max_bisector_height_angle:\r\n                            max_bisector_height_angle = bisector_height_angle\r\n                            max_triangle = triangle\r\n                            max_point = point\r\n                            max_bisector = bisector\r\n                            max_height = height\r\n                    except NoTriangleException:\r\n                        pass\r\n\r\n        if not max_triangle:\r\n            raise NoTriang"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyInterpreterInspection"
  },
  "hash": "1600e12db1441b8338eb85d31cdceb1e2099ecd941477df0ac6de98c2f71c466"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "An invalid interpreter",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "No Python interpreter configured for the project",
  "detailsInfo": "Reports problems if there is no Python interpreter configured for the project or if the interpreter is invalid. Without a properly\nconfigured interpreter, you cannot execute your Python scripts and benefit from some Python code insight features.\n\nThe IDE provides quick access to the interpreter settings.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/main.py",
      "language": "Python",
      "line": 1,
      "offset": 1,
      "length": 82,
      "code": {
        "startLine": 1,
        "length": 82,
        "offset": 0,
        "surroundingCode": "\"\"\"\nЛабораторная работа №1 по курсу \"Компьютерная Графика\"\nОрлов Алексей (ИУ7-34Б)\n\"\"\"\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyInterpreterInspection"
  },
  "hash": "33a73babab6d8c7efedd19351ee3bb7ae40ac702c4f7b9b4a11f38144cd20029"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "An invalid interpreter",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "No Python interpreter configured for the project",
  "detailsInfo": "Reports problems if there is no Python interpreter configured for the project or if the interpreter is invalid. Without a properly\nconfigured interpreter, you cannot execute your Python scripts and benefit from some Python code insight features.\n\nThe IDE provides quick access to the interpreter settings.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/canvas.py",
      "language": "Python",
      "line": 1,
      "offset": 1,
      "length": 127,
      "code": {
        "startLine": 1,
        "length": 127,
        "offset": 0,
        "surroundingCode": "from PyQt6.QtCore import QPoint\nfrom PyQt6.QtGui import QPainter, QColor, QPen\nfrom PyQt6.QtWidgets import QWidget, QSizePolicy\n\nfrom figures.line import Line"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyInterpreterInspection"
  },
  "hash": "54b4b8144361cc2159c2f1cbe25ee4859c179b2560cc899e7431a0bf5f8bb606"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "An invalid interpreter",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "No Python interpreter configured for the project",
  "detailsInfo": "Reports problems if there is no Python interpreter configured for the project or if the interpreter is invalid. Without a properly\nconfigured interpreter, you cannot execute your Python scripts and benefit from some Python code insight features.\n\nThe IDE provides quick access to the interpreter settings.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/points_table.py",
      "language": "Python",
      "line": 1,
      "offset": 1,
      "length": 171,
      "code": {
        "startLine": 1,
        "length": 171,
        "offset": 0,
        "surroundingCode": "from PyQt6.QtCore import Qt\nfrom PyQt6.QtGui import QCursor\nfrom PyQt6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QVBoxLayout, QSizePolicy, QSpacerItem, \\\n    QScrollArea\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyInterpreterInspection"
  },
  "hash": "894f0f7870e7ae7532883008e77df8bb6e1f75fc381620bb7711fc75e86a714f"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "An invalid interpreter",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "No Python interpreter configured for the project",
  "detailsInfo": "Reports problems if there is no Python interpreter configured for the project or if the interpreter is invalid. Without a properly\nconfigured interpreter, you cannot execute your Python scripts and benefit from some Python code insight features.\n\nThe IDE provides quick access to the interpreter settings.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/figures/point.py",
      "language": "Python",
      "line": 1,
      "offset": 1,
      "length": 352,
      "code": {
        "startLine": 1,
        "length": 352,
        "offset": 0,
        "surroundingCode": "class Point:\r\n    def __init__(self, x, y):\r\n        self.x = x\r\n        self.y = y\r\n\r\n    def __iter__(self):\r\n        yield self.x\r\n        yield self.y\r\n\r\n    def __str__(self):\r\n        x = self.x if isinstance(self.x, int) else f'{self.x:.4g}'.strip()\r\n        y = self.y if isinstance(self.y, int) else f'{self.y:.4g}'.strip()\r\n        return f\"({x}, {y})\"\r\n\r\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyInterpreterInspection"
  },
  "hash": "99ab1bd0ba382a556d47d0f318ae679752bde67ad5fc1f0224b228f92e870d8b"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "An invalid interpreter",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "No Python interpreter configured for the project",
  "detailsInfo": "Reports problems if there is no Python interpreter configured for the project or if the interpreter is invalid. Without a properly\nconfigured interpreter, you cannot execute your Python scripts and benefit from some Python code insight features.\n\nThe IDE provides quick access to the interpreter settings.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/point_dialog.py",
      "language": "Python",
      "line": 1,
      "offset": 1,
      "length": 1219,
      "code": {
        "startLine": 1,
        "length": 1219,
        "offset": 0,
        "surroundingCode": "from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDoubleSpinBox, QHBoxLayout, QPushButton\r\n\r\n\r\nclass PointDialog(QDialog):\r\n    def __init__(self, x=0, y=0):\r\n        super().__init__()\r\n\r\n        layout = QVBoxLayout(self)\r\n\r\n        layout.addWidget(QLabel(\"Ввод X:\"))\r\n\r\n        self._x_edit = QDoubleSpinBox()\r\n        self._x_edit.setRange(-1e300, 1e300)\r\n        self._x_edit.setValue(float(x))\r\n        layout.addWidget(self._x_edit)\r\n\r\n        layout.addWidget(QLabel(\"Ввод Y:\"))\r\n\r\n        self._y_edit = QDoubleSpinBox()\r\n        self._y_edit.setRange(-1e300, 1e300)\r\n        self._y_edit.setValue(float(y))\r\n        layout.addWidget(self._y_edit)\r\n\r\n        buttons_layout = QHBoxLayout()\r\n        buttons_layout.setContentsMargins(0, 0, 0, 0)\r\n        layout.addLayout(buttons_layout)\r\n\r\n        self._button_ok = QPushButton(\"Ок\")\r\n        self._button_ok.clicked.connect(self.accept)\r\n        buttons_layout.addWidget(self._button_ok)\r\n\r\n        self._button_cancel = QPushButton(\"Отмена\")\r\n        self._button_cancel.clicked.connect(self.reject)\r\n        buttons_layout.addWidget(self._button_cancel)\r\n\r\n        self._x_edit.selectAll()\r\n\r\n    @property\r\n    def res(self):\r\n        return self._x_edit.value(), self._y_edit.value()\r\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyInterpreterInspection"
  },
  "hash": "d6060d93a32d0c3718da839ce9ff4bbc0c7e2800a2fc904a93c1f8c8440ce7fd"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'PyQt6'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/main.py",
      "language": "Python",
      "line": 8,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 6,
        "length": 5,
        "offset": 17,
        "surroundingCode": "import sys\n\nfrom PyQt6.QtCore import Qt\nfrom PyQt6.QtWidgets import QMainWindow, QWidget, QHBoxLayout, QPushButton, QVBoxLayout, \\\n    QMessageBox, QApplication, QSizePolicy, QLabel"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "20a157b55d61d8b0edf5bb4272a9f295de9caf902a08c4ae62dfa56dee3ec1e0"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'PyQt6'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/canvas.py",
      "language": "Python",
      "line": 2,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 1,
        "length": 5,
        "offset": 37,
        "surroundingCode": "from PyQt6.QtCore import QPoint\nfrom PyQt6.QtGui import QPainter, QColor, QPen\nfrom PyQt6.QtWidgets import QWidget, QSizePolicy\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "254e1e0bf5520f03a8cdd60235a76f8054fd3536afa255588fa548e21f761d54"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'PyQt6'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/points_table.py",
      "language": "Python",
      "line": 1,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 1,
        "length": 5,
        "offset": 5,
        "surroundingCode": "from PyQt6.QtCore import Qt\nfrom PyQt6.QtGui import QCursor\nfrom PyQt6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QVBoxLayout, QSizePolicy, QSpacerItem, \\"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "3f7a1eba87813eedf0f89b6894d906ed9beab8ff1d1e0b3c14e2ea27cb37f4db"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'PyQt6'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/points_table.py",
      "language": "Python",
      "line": 2,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 1,
        "length": 5,
        "offset": 33,
        "surroundingCode": "from PyQt6.QtCore import Qt\nfrom PyQt6.QtGui import QCursor\nfrom PyQt6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QVBoxLayout, QSizePolicy, QSpacerItem, \\\n    QScrollArea"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "4acb4964d7afe72d7889a4d17ddf0958b9be7f9f87e0e726ff7b5138de811cf2"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'PyQt6'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/point_dialog.py",
      "language": "Python",
      "line": 1,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 1,
        "length": 5,
        "offset": 5,
        "surroundingCode": "from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDoubleSpinBox, QHBoxLayout, QPushButton\r\n\r\n\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "5963ac2d0e1f36b1b49ddacb325b270771ee4e0c9bcac48d52b736ba541cdf1e"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'QPoint'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/canvas.py",
      "language": "Python",
      "line": 1,
      "offset": 26,
      "length": 6,
      "code": {
        "startLine": 1,
        "length": 6,
        "offset": 25,
        "surroundingCode": "from PyQt6.QtCore import QPoint\nfrom PyQt6.QtGui import QPainter, QColor, QPen\nfrom PyQt6.QtWidgets import QWidget, QSizePolicy"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "679698b59d776d6859e35e6efcd42584b14acad05af05388e27c0989429f3788"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'QDialog'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/point_dialog.py",
      "language": "Python",
      "line": 1,
      "offset": 29,
      "length": 7,
      "code": {
        "startLine": 1,
        "length": 7,
        "offset": 28,
        "surroundingCode": "from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDoubleSpinBox, QHBoxLayout, QPushButton\r\n\r\n\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "7f2b68a6b386401a374cfee36df543a68ce0b7b532a5e1812e816ad4c804bfd6"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'QLabel'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/point_dialog.py",
      "language": "Python",
      "line": 1,
      "offset": 51,
      "length": 6,
      "code": {
        "startLine": 1,
        "length": 6,
        "offset": 50,
        "surroundingCode": "from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDoubleSpinBox, QHBoxLayout, QPushButton\r\n\r\n\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "861284a369a6b3a1962b85bb18d626292e0eaaf4a1373114c254de3b5fc86aa3"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'Qt'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/main.py",
      "language": "Python",
      "line": 8,
      "offset": 26,
      "length": 2,
      "code": {
        "startLine": 6,
        "length": 2,
        "offset": 37,
        "surroundingCode": "import sys\n\nfrom PyQt6.QtCore import Qt\nfrom PyQt6.QtWidgets import QMainWindow, QWidget, QHBoxLayout, QPushButton, QVBoxLayout, \\\n    QMessageBox, QApplication, QSizePolicy, QLabel"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "8a8d3bebe6c1d3de16851acb5c32995438cd3e56775b8237c939d0379abcbf40"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'int'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/figures/point.py",
      "language": "Python",
      "line": 11,
      "offset": 42,
      "length": 3,
      "code": {
        "startLine": 9,
        "length": 3,
        "offset": 67,
        "surroundingCode": "\r\n    def __str__(self):\r\n        x = self.x if isinstance(self.x, int) else f'{self.x:.4g}'.strip()\r\n        y = self.y if isinstance(self.y, int) else f'{self.y:.4g}'.strip()\r\n        return f\"({x}, {y})\"\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "8f2a09dcd88dcdcfe8a67b8c23d91de0915c9526558e7ee7ba219fcb5a79f9b5"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'PyQt6'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/main.py",
      "language": "Python",
      "line": 9,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 7,
        "length": 5,
        "offset": 34,
        "surroundingCode": "\nfrom PyQt6.QtCore import Qt\nfrom PyQt6.QtWidgets import QMainWindow, QWidget, QHBoxLayout, QPushButton, QVBoxLayout, \\\n    QMessageBox, QApplication, QSizePolicy, QLabel\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "991439b46899ab6ac36684f108e36e866d7e9f5d282045ba21cdabcacee1c751"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'isinstance'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/figures/point.py",
      "language": "Python",
      "line": 12,
      "offset": 23,
      "length": 10,
      "code": {
        "startLine": 10,
        "length": 10,
        "offset": 122,
        "surroundingCode": "    def __str__(self):\r\n        x = self.x if isinstance(self.x, int) else f'{self.x:.4g}'.strip()\r\n        y = self.y if isinstance(self.y, int) else f'{self.y:.4g}'.strip()\r\n        return f\"({x}, {y})\"\r\n\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "99a87c316ed09230578c746aabc242be8a5a89817273c09fdedd85e37875a179"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'Qt'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/points_table.py",
      "language": "Python",
      "line": 1,
      "offset": 26,
      "length": 2,
      "code": {
        "startLine": 1,
        "length": 2,
        "offset": 25,
        "surroundingCode": "from PyQt6.QtCore import Qt\nfrom PyQt6.QtGui import QCursor\nfrom PyQt6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QVBoxLayout, QSizePolicy, QSpacerItem, \\"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "9c22380dd986c418bd9fb5857cceead9f7b31709e72f0dd798279c71d164cd21"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'isinstance'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/figures/point.py",
      "language": "Python",
      "line": 11,
      "offset": 23,
      "length": 10,
      "code": {
        "startLine": 9,
        "length": 10,
        "offset": 48,
        "surroundingCode": "\r\n    def __str__(self):\r\n        x = self.x if isinstance(self.x, int) else f'{self.x:.4g}'.strip()\r\n        y = self.y if isinstance(self.y, int) else f'{self.y:.4g}'.strip()\r\n        return f\"({x}, {y})\"\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "9fdf923aa190241970d32577d1d2d42c0485620c31e6f1a25c24cf3a6e11f3b5"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "High",
  "comment": "Unused import statement `from PyQt6.QtGui import QCursor`",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/points_table.py",
      "language": "Python",
      "line": 2,
      "offset": 1,
      "length": 31,
      "code": {
        "startLine": 1,
        "length": 31,
        "offset": 28,
        "surroundingCode": "from PyQt6.QtCore import Qt\nfrom PyQt6.QtGui import QCursor\nfrom PyQt6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QVBoxLayout, QSizePolicy, QSpacerItem, \\\n    QScrollArea"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "cbd8277ebd89ba395e2f0c7a2b823650593dc3ebfa4fb3f6cf852a7ec22b22ec"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "No module named 'sys'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/main.py",
      "language": "Python",
      "line": 6,
      "offset": 8,
      "length": 3,
      "code": {
        "startLine": 4,
        "length": 3,
        "offset": 12,
        "surroundingCode": "\"\"\"\n\nimport sys\n\nfrom PyQt6.QtCore import Qt"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "cd1143a831487cfabfa1636654768438e866fe9367752c38983bf9a924506cac"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'QPainter'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/canvas.py",
      "language": "Python",
      "line": 2,
      "offset": 25,
      "length": 8,
      "code": {
        "startLine": 1,
        "length": 8,
        "offset": 56,
        "surroundingCode": "from PyQt6.QtCore import QPoint\nfrom PyQt6.QtGui import QPainter, QColor, QPen\nfrom PyQt6.QtWidgets import QWidget, QSizePolicy\n"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "d4461cc7b4f79b1da3f71e496477f32aa9a73592ebc9aca6a73b939ae1e5a8ff"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'int'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/figures/point.py",
      "language": "Python",
      "line": 12,
      "offset": 42,
      "length": 3,
      "code": {
        "startLine": 10,
        "length": 3,
        "offset": 141,
        "surroundingCode": "    def __str__(self):\r\n        x = self.x if isinstance(self.x, int) else f'{self.x:.4g}'.strip()\r\n        y = self.y if isinstance(self.y, int) else f'{self.y:.4g}'.strip()\r\n        return f\"({x}, {y})\"\r\n\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "e7e560797ab6fd7f41f3b59dc6593b3d6266fdd87b4523c5e17e0911511677c2"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'QVBoxLayout'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/point_dialog.py",
      "language": "Python",
      "line": 1,
      "offset": 38,
      "length": 11,
      "code": {
        "startLine": 1,
        "length": 11,
        "offset": 37,
        "surroundingCode": "from PyQt6.QtWidgets import QDialog, QVBoxLayout, QLabel, QDoubleSpinBox, QHBoxLayout, QPushButton\r\n\r\n\r"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "ea56402e1669191d0a10b3534879e506165de1066371c292b1e61b869034e19f"
},{
  "tool": "Code Inspection",
  "category": "Python",
  "type": "Unresolved references",
  "tags": [
    "Sanity"
  ],
  "severity": "Critical",
  "comment": "Unresolved reference 'PyQt6'",
  "detailsInfo": "Reports references in your code that cannot be resolved.\n\nIn a dynamically typed language, this is possible in a limited number of cases.\n\nIf a reference type is unknown, then its attributes are not highlighted as unresolved even if you know that they should be:\n\n\n    def print_string(s):\n      print(s.abc())\n\nIn this code fragment `s` is always a string and `abc` should be highlighted as unresolved. However, `s`\ntype is inferred as `Any` and no warning is reported.\n\nThe IDE provides quick-fix actions to add missing references on-the-fly.",
  "sources": [
    {
      "type": "file",
      "path": "lab_01/canvas.py",
      "language": "Python",
      "line": 1,
      "offset": 6,
      "length": 5,
      "code": {
        "startLine": 1,
        "length": 5,
        "offset": 5,
        "surroundingCode": "from PyQt6.QtCore import QPoint\nfrom PyQt6.QtGui import QPainter, QColor, QPen\nfrom PyQt6.QtWidgets import QWidget, QSizePolicy"
      }
    }
  ],
  "attributes": {
    "module": "project",
    "inspectionName": "PyUnresolvedReferencesInspection"
  },
  "hash": "fa1b381e843b37b6d84d8e6a2da7cf4de5674e29e4a7d655422386deba663bdd"
}]}